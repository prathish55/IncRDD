package incr
import com.prat._
import org.apache.spark.{Partition, TaskContext}
import org.apache.spark.rdd.RDD
import reflect.ClassTag
import org.apache.spark.SparkContext._
import org.apache.spark._
import org.apache.spark.storage.StorageLevel




class IncrementalRDD[K: ClassTag, V: ClassTag](
    private val newRDD: RDD[IncrRDDPartition[K, V]]) 
    extends RDD[(K, V)](newRDD.context,List(new OneToOneDependency(newRDD))) {

    

    override protected def getPartitions: Array[Partition] = newRDD.partitions

    override def compute(split: Partition, context: TaskContext): Iterator[(K, V)] = {
	firstParent[IncrRDDPartition[K, V]].iterator(split, context).next.iterator
    } 

    override protected def getPreferredLocations(s: Partition): Seq[String] =
	newRDD.preferredLocations(s)

    override val partitioner = newRDD.partitioner

    def add(k: K, v: V): IncrementalRDD[K, V] = updateValue[V](Map(k -> v), (id, a) => a, (id, a, b) => b)

    def update(k: K, v: V): IncrementalRDD[K, V] = updateValue[V](Map(k -> v), (id, a) => a, (id, a, b) => b)

    def updateValue[U: ClassTag](kvs: Map[K, U], z: (K, U) => V, f: (K, V, U) => V): IncrementalRDD[K, V] = {
	val updates = context.parallelize(kvs.toSeq).partitionBy(partitioner.get)
	val partitioned = updates.partitionBy(partitioner.get)
	val newPartitionsRDD = newRDD.zipPartitions(partitioned, true)(new MultiputZipper(z,f))
	new IncrementalRDD(newPartitionsRDD)	
    } 

     private type OtherZipPartitionsFunction[V2, V3] =
    	Function2[Iterator[IncrRDDPartition[K, V]], Iterator[(K, V2)],
	Iterator[IncrRDDPartition[K, V3]]]


    private class MultiputZipper[U](z: (K, U) => V, f: (K, V, U) => V)  extends OtherZipPartitionsFunction[U, V]
	with Serializable {
    def apply(thisIter: Iterator[IncrRDDPartition[K, V]], otherIter: Iterator[(K, U)])
      : Iterator[IncrRDDPartition[K, V]] = {
      val thisPart = thisIter.next()
      Iterator(thisPart.updateValue(otherIter, z, f))
    	}
    }
	
    def delete(ks: K): IncrementalRDD[K, V] = {
    	val deletions = context.parallelize(Map(ks->()).toSeq).partitionBy(partitioner.get)
    	val partitioned = deletions.partitionBy(partitioner.get)
	val newPartitionsRDD = newRDD.zipPartitions(partitioned, true)(new DeleteZipper)
	new IncrementalRDD(newPartitionsRDD)
    }

    private class DeleteZipper extends OtherZipPartitionsFunction[Unit, V] with Serializable {
    	def apply(thisIter: Iterator[IncrRDDPartition[K, V]], otherIter: Iterator[(K, Unit)])
      	: Iterator[IncrRDDPartition[K, V]] = {
      	val thisPart = thisIter.next()
      	Iterator(thisPart.delete(otherIter.map(_._1)))
    	}
    }

    def get(ks: K): IncrementalRDD[K, V] = {
	/*val getting = context.parallelize(Map(ks->()).toSeq).partitionBy(partitioner.get)
    	val partitioned = getting.partitionBy(partitioner.get)
	//val thisIter= Iterator[partitioned]

	val thisPart= Iterator[IncrRDDPartition[K, V]].next()
	Iterator(thisPart.get(ks))
	
	//IncrRDDPartition.get(ks)
	//IncrRDDPartition[K, V].get(ks)
	

	val partitions= Map(ks -> partitioner.get.getPartition(ks))
	val p = partitions.keys.toSeq
	firstParent[IncrRDDPartition[K, V]].next.get(ks)
	*/

	val getting = context.parallelize(Map(ks->()).toSeq).partitionBy(partitioner.get)
    	val partitioned = getting.partitionBy(partitioner.get)
	val newPartitionsRDD = newRDD.zipPartitions(partitioned, true)(new GetZipper)
	//val Vval= new GetZipper
	//Option(new IncrementalRDD(newPartitionsRDD).first._2)
	new IncrementalRDD(newPartitionsRDD)
    }
	

	private class GetZipper extends OtherZipPartitionsFunction[Unit, V] with Serializable {
    	def apply(thisIter: Iterator[IncrRDDPartition[K, V]], otherIter: Iterator[(K, Unit)])
      	: Iterator[IncrRDDPartition[K, V]] = {
      	val thisPart = thisIter.next()
      	Iterator(thisPart.get(otherIter.map(_._1)))
    	}
    }
	

}


object IncrementalRDD {

    def apply[K: ClassTag , V: ClassTag](elems: RDD[(K, V)]): IncrementalRDD[K, V] = 
	updatable[K, V, V](elems, (id, a) => a, (id, a, b) => b)

    def updatable[K: ClassTag,  U: ClassTag, V: ClassTag]
      (elems: RDD[(K, U)], z: (K, U) => V, f: (K, V, U) => V)
    : IncrementalRDD[K, V] = {
    val elemsPartitioned =
      if (elems.partitioner.isDefined) elems
      else elems.partitionBy(new HashPartitioner(elems.partitions.size))
    val partitions = elemsPartitioned.mapPartitions[IncrRDDPartition[K, V]](
      iter => Iterator(IncrementalPartition(iter, z, f)),
      preservesPartitioning = true)
    new IncrementalRDD(partitions)
}


//   def main(args: Array[String] ) {
//	}
}

